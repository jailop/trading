use crate::ema::EMA;

/**
 * This struct is used to represent the Moving Average
 * Convergence Divergence (MACD) indicator. The MACD is
 * calculated as the difference between two Exponential
 * Moving Averages (EMAs) of different periods. The signal
 * line is the EMA of the MACD line. The MACD indicator
 * generates three values: the MACD line, the signal line,
 * and the histogram bar value.
 */
pub struct MACD {
    short: EMA,
    long: EMA,
    signal: EMA,
    start: usize,
    len: usize,
}

/**
 * This struct is used to represent a thriplet of values
 * generated by the MACD indicator. The values are:
 *
 * - macd: The MACD line, which is the difference between
 *         short and long EMAs.
 * - signal: The signal line, which is the EMA of the MACD line.
 * - hist: Histogram bar value, which is the difference between
 *         the MACD and signal lines.
 */
pub struct MACDValue {
    pub macd: f64,
    pub signal: f64,
    pub hist: f64,
}

impl MACD {
    /**
     * This function creates a new MACD indicator with the
     * given short, long, and signal periods. The alpha value
     * is used to calculate the smoothing factor for the EMAs.
     */
    pub fn new(short_period: usize, long_period: usize, signal_period: usize,
        alpha: f64) -> Self
    {
        let short = EMA::new(short_period, alpha);
        let long = EMA::new(long_period, alpha);
        let signal = EMA::new(signal_period, alpha);
        MACD {
            short,
            long,
            signal,
            start: long_period,
            len: 0,
        }    
    }

    /**
     * This function updates the MACD indicator with a new
     * value and returns the MACD value triplet. If the MACD
     * indicator has not yet started.
     */
    pub fn update(&mut self, value: f64) -> MACDValue {
        self.len += 1;
        self.short.update(value);
        self.long.update(value);
        if self.len >= self.start {
            self.signal.update(self.short.get() - self.long.get());
        }
        self.get()
    }

    /**
     * This function returns the current MACD value triplet.
     * If the MACD indicator has not yet started to generate
     * valid values, then NaN values are returned.
     */
    pub fn get(&self) -> MACDValue {
        if self.len >= self.start {
            let macd = self.short.get() - self.long.get();
            let signal = self.signal.get();
            MACDValue {
                macd,
                signal,
                hist: macd - signal,
            }
        } else {
            MACDValue {
                macd: std::f64::NAN,
                signal: std::f64::NAN,
                hist: std::f64::NAN,
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_ema() {
        // Data for this test was taken from:
        // https://investexcel.net/how-to-calculate-macd-in-excel/
        let mut macd = MACD::new(12, 26, 9, 2.0);
        let ts: Vec<f64> = vec![
            459.99, 448.85, 446.06, 450.81, 442.8,
            448.97, 444.57, 441.4, 430.47, 420.05,
            431.14, 425.66, 430.58, 431.72, 437.87,
            428.43, 428.35, 432.5, 443.66, 455.72,
            454.49, 452.08, 452.73, 461.91, 463.58,
            461.14, 452.08, 442.66, 428.91, 429.79,
            431.99, 427.72, 423.2, 426.21, 426.98,
            435.69, 434.33, 429.8, 419.85, 426.24,
            402.8, 392.05, 390.53, 398.67, 406.13,
            405.46, 408.38, 417.2, 430.12, 442.78,
            439.29, 445.52, 449.98, 460.71, 458.66,
            463.84, 456.77, 452.97, 454.74, 443.86,
            428.85, 434.58, 433.26, 442.93, 439.66,
            441.3
        ];
        let res: Vec<f64> = vec![
            3.03752586873395, 1.90565222933578, 1.05870843537763,
            0.410640325343509, -0.152012994298479, -0.790034731709356,
            -1.33810041258299, -2.17197457979186, -3.30783450954566,
            -4.59014109868629, -5.75668618055047, -6.65738137622787,
            -7.33974702300915, -7.78618154079804, -7.90287193112745,
            -7.58262468963905, -6.78603605354027, -5.77285851501159,
            -4.5644861655494, -3.21555428301682, -1.67071586469137,
            -0.112968660984149, 1.45411118991556, 2.82877971367526,
            3.94371200786538, 4.85665087093101, 5.41047306555065,
            5.45836826902626, 5.26562556819742, 4.89909832689482,
            4.58597343224244, 4.26011131701701, 3.96060129677866
        ];
        for i in 0..ts.len() {
            let y = macd.update(ts[i]).signal;
            if i < 33 {
                assert!(y.is_nan());
            } else {
                assert!((y - res[i - 33]).abs() < 1e-3);
            }
        }
    }
}
